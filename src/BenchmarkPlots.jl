module BenchmarkPlots

using BenchmarkTools
using ProgressMeter
using Makie
using Colors
using DataFrames
using CSV

export
    benchmarkplot


# Source codes

"""
    benchmarkplot(functions::Array, gen::Function, NumData::Array{Int}; kw...)

Benchmark multiple `functions` using different lengths of data generated by function `gen`.
NumData is an `Array` or other iteratables. Returns a `Tuple` of `scene`. `scene` and `layout` are defined in `Makie`.

# Core Algorithm
For each element in `NumData`:
1. `gen` generates data with length corresponded 
2. `BenchmarkTools.@benchmark` tunes each function in `functions` and restore timings in an array
3. Plot figure

# Keywords
- `title`: figure title. Default is `"Benchmark"`
- `logscale`: If `true`, plot axes in log10 scale. Default is `true`.
- `xlabel`: label of x-axis. Default is `logscale ? "log10(N)" : "N"`
- `ylabel`: label of y-axis. Default is `logscale ? "log10(Timing [ns])" : "Timing [ns]"`
- `resolution`: figure resolution. Default is `(1600, 900)`
- `names`: alternative names of testing functions. Default is `string.(functions)`, which is exactly the same with function names
- `colors`: colors of each benchmark line. Default is `nothing`, meaning random colors are assigned to lines.
- `savelog::Bool`: If `true`, save processed data in `csv`. The name of logging file depends on analysis function
- `savefolder`: set the directory to save logging file
- `stairplot`: If `true`, plot line in stair style (which is more concrete). Default is `true`

# Examples
```jl
using BenchmarkPlots, Makie
scene, layout, timings = benchmarkplot(
    [sum, minimum],
    rand,
    [10^i for i in 1:4],
)
display(scene)
display(timings)
Makie.save("benchmark_sum_miminum.png", scene)
```
"""
function benchmarkplot(functions::Array, gen::Function, NumData;
        title = "Benchmark",
        names = string.(functions),
        resolution = (1600, 900),
        colors = nothing,
        logscale = true,
        xlabel = logscale ? "log10(N)" : "N",
        ylabel = logscale ? "log10(Timing [ns])" : "Timing [ns]",
        savelog = true,
        savefolder = pwd(),
        stairplot = true, #TODO
    kw...)
    scene, layout = layoutscene(;resolution)
    ax = layout[1,1] = Axis(
        scene; title, xlabel, ylabel
    )

    if isnothing(colors)
        colors = [RGB(rand(3)...) for i in functions]
    else
        if length(colors) < length(functions)
            colors = [colors...; [RGB(rand(3)...) for i in 1:length(functions)-length(colors)]]
        end
    end

    timings = DataFrame(N = NumData)
    for f in functions
        timings[:, string(f)] = zeros(length(NumData))
    end

    progress = Progress(length(NumData) * length(functions))
    for k in eachindex(NumData)
        let data = gen(NumData[k])
            for i in eachindex(functions)
                if data isa Tuple
                    result = @benchmark $(functions[i])($(data...))
                else
                    result = @benchmark $(functions[i])($(data))
                end
                @inbounds timings[k,i+1] = mean(result.times)
                next!(progress; showvalues = [("NumData", NumData[k]), ("Function", string(functions[i]))])
            end
        end
    end

    if logscale
        p = [Makie.lines!(ax, log10.(timings.N), log10.(timings[!,i+1]); color = colors[i]) for i in eachindex(functions)]
    else
        p = [Makie.lines!(ax, timings.N, timings[!,i+1]; color = colors[i]) for i in eachindex(functions)]
    end
    legend = layout[1,2] = Legend(scene, p, names)

    if savelog
        outputfile = joinpath(savefolder, "benchmark.csv")
        CSV.write(outputfile, timings)
        println("Benchmark timings saved to ", outputfile)
    end

    return scene, layout, timings
end

end # module
