module BenchmarkPlots

using BenchmarkTools
using ProgressMeter
using Makie
using Colors
using ColorSchemes
using DataFrames
using CSV

export
    benchmarkplot!,
    benchmarkplot


# Source codes

function benchmarkplot!(ax, df::DataFrame;
        colors = nothing,
        logscale = true,
        kw...
    )
    NumFuncs = size(df)[2] - 1
    if isnothing(colors)
        colors = [RGB(rand(3)...) for i in 1:NumFuncs]
    else
        if length(colors) < NumFuncs
            colors = [colors...; [RGB(rand(3)...) for i in 1:NumFuncs-length(colors)]]
        end
    end

    if logscale
        plots = [Makie.lines!(ax, log10.(df.N), log10.(df[!,i+1]); color = colors[i], kw...) for i in 1:NumFuncs]
    else
        plots = [Makie.lines!(ax, df.N, df[!,i+1]; color = colors[i], kw...) for i in 1:NumFuncs]
    end

    return plots
end

"""
    benchmarkplot(functions::Array, gen::Function, NumData::Array{Int}; kw...)

Benchmark multiple `functions` using different lengths of data generated by function `gen`.
NumData is an `Array` or other iteratables. Returns a `Tuple` of `scene`. `scene` and `layout` are defined in `Makie`.

# Core Algorithm
For each element in `NumData`:
1. `gen` generates data with length corresponded 
2. `BenchmarkTools.@benchmark` tunes each function in `functions` and restore timings in an array
3. Plot figure

# Keywords
- `title`: figure title. Default is `"Benchmark"`
- `logscale`: If `true`, plot axes in log10 scale. Default is `true`.
- `xlabel`: label of x-axis. Default is `logscale ? "log10(N)" : "N"`
- `ylabel`: label of y-axis. Default is `logscale ? "log10(Timing [ns])" : "Timing [ns]"`
- `resolution`: figure resolution. Default is `(1600, 900)`
- `names`: alternative names of testing functions. Default is `string.(functions)`, which is exactly the same with function names
- `colors`: colors of each benchmark line. Default is `nothing`, meaning random colors are assigned to lines.
- `savelog::Bool`: If `true`, save processed data in `csv`. The name of logging file depends on analysis function
- `savefolder`: set the directory to save logging file
- `stairplot`: If `true`, plot line in stair style (which is more concrete). Default is `true`

# Examples
```jl
using BenchmarkPlots, Makie
scene, layout, df = benchmarkplot(
    [sum, minimum],
    rand,
    [10^i for i in 1:4],
)
display(scene)
display(df)
Makie.save("benchmark_sum_miminum.png", scene)
```
"""
function benchmarkplot(functions::Array, gen::Function, NumData;
        title = "Benchmark",
        labels = string.(functions),
        resolution = (1600, 900),
        colors = ColorSchemes.tab10.colors,
        logscale = true,
        xlabel = logscale ? "log10(N)" : "N",
        ylabel = logscale ? "log10(Timing [ns])" : "Timing [ns]",
        savelog = true,
        savefolder = pwd(),
        stairplot = true, #TODO
        kw...
    )
    # Initialize plotting
    scene, layout = layoutscene(;resolution)
    ax = layout[1,1] = Axis(
        scene; title, xlabel, ylabel
    )
    
    # Process data
    df = DataFrame(N = NumData)
    for f in functions
        df[:, string(f)] = zeros(length(NumData))
    end

    progress = Progress(length(NumData) * length(functions))
    for k in eachindex(NumData)
        let data = gen(NumData[k])
            for i in eachindex(functions)
                f = functions[i]
                if data isa Tuple
                    result = @benchmark ($f)($(data...))
                else
                    result = @benchmark ($f)($(data))
                end
                @inbounds df[k,i+1] = mean(result.times)
                next!(progress; showvalues = [("NumData", NumData[k]), ("Function", string(functions[i]))])
            end
        end
    end

    if savelog
        outputfile = joinpath(savefolder, "benchmark.csv")
        CSV.write(outputfile, df)
        println("Benchmark timings saved to ", outputfile)
    end

    # Plot data
    plots = benchmarkplot!(ax, df; colors, logscale, kw...)
    legend = layout[1,2] = Legend(scene, plots, labels)

    return scene, layout, df
end

end # module
